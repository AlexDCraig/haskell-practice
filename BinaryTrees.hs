module Tree where

-- | Integer-labeled binary trees.
data Tree = Node Int Tree Tree   -- ^ Internal nodes
          | Leaf Int             -- ^ Leaf nodes
  deriving (Eq,Show)


-- | The integer at the left-most node of a binary tree. 
leftmost :: Tree -> Int
leftmost (Leaf i)     = i
leftmost (Node _ l _) = leftmost l


-- | The integer at the right-most node of a binary tree. 
-- Explanation: Base case - return the integer at a Leaf. Inductive- given a Node with any integer and any left subtree, call the rightmost function again on 
-- the right subtree given.

rightmost :: Tree -> Int
rightmost (Leaf i)     = i
rightmost (Node _  _ l) = rightmost l


-- | Get the maximum integer from a binary tree.
-- Explanation: Two cases. Base case- given a Leaf, return the value of the leaf. Inductive step- Return the maximum value between the current integer
-- and the maximum value resulting between calling maxInt on its left and right subtrees.

maxInt :: Tree -> Int
maxInt (Leaf i)              = i
maxInt (Node i l r)          = max i (max (maxInt l) (maxInt r))


-- | Get the minimum integer from a binary tree. 
-- Explanation: see MaxInt example and change each max to a min and each maxInt to a minInt

minInt :: Tree -> Int
minInt (Leaf i)              = i
minInt (Node i l r)          = min i (min (minInt l) (minInt r))

-- | Get the height of a binary tree
height :: Tree -> Int
height (Leaf i) = 0
height (Node i l r) = 1 + max (height l) (height r)

-- | Get the sum of the integers in a binary tree.
-- Explanation: Base case - return integer. Inductive step - given Node consisting of int, left subtree, right subtree,
-- return the integer given + the result of calling sumInts on the left subtree + the result of calling sumInts on the right subtree
-- which means "add first node to the sum of its left subtree and then add the right subtree"
--
sumInts :: Tree -> Int
sumInts (Leaf i)     = i
sumInts (Node i l r) = i + sumInts l + sumInts r

-- | The list of integers encountered by a pre-order traversal of the tree.
-- Explanation: preorder traversal is Root node -> recursively visit left subtree -> recursively visit right subtree
-- We get an Tree and must return a list of integers.
-- Base case: Return a singleton list of one integer located at the Leaf
-- Recursive case: Return the current integer appended to a list from the visit to the left subtree appended to a list from the visit to the  right subtree
preorder :: Tree -> [Int]
preorder (Leaf i)     = [i]
preorder (Node i l r) = [i] ++ preorder l ++ preorder r


-- | The list of integers encountered by an in-order traversal of the tree.
-- Explanation: same functional logic as pre-order traversal except applied
-- to in-order traversal which is recursively visit left subtree, then 
-- the root, then recursively visit right subtree
inorder :: Tree -> [Int]
inorder (Leaf i)     = [i]
inorder (Node i l r) = inorder l ++ [i] ++ inorder r


-- | Check whether a binary tree is a binary search tree.
--   Explanation: Definition of binary search tree is that each node
-- is either (1) a Leaf or (2) its left child node (if it exists) is less 
-- than its parent node and its right child node (if it exists) 
-- is greater than its parent node.
-- Idea: call inorder on the Tree then verify its in ascending order
-- by definition a tree consisting of only 1 node is a BST
-- Helper function checkAscending: Take the list generated by inorder
-- and return true if its in ascending order. Logic is that if its an
-- empty set its in order, if its a set consisting of one number 
-- its in order, then recursively call a preceding number comparing it to its 
-- succeeding number through the whole list
checkAscending :: [Int] -> Bool
checkAscending [] = True
checkAscending [baseNum] = True
checkAscending (precNum:succNum:precNumsuccNum) = precNum <= succNum && checkAscending (succNum:precNumsuccNum)

isBST :: Tree -> Bool
isBST (Leaf i)     = True
isBST (Node i l r) = checkAscending (inorder (Node i l r))

-- | Check whether a number is contained in a binary search tree.
--   (You may assume that the given tree is a binary search tree.)

-- quick helper function only used for if there's just a leaf
-- returns true if the value held at the leaf node is the same
-- as the number we want
checkEquals :: Int -> Int -> Bool
checkEquals x y = x == y

-- If it's just a leaf, use helper function
-- If it's a tree with children, get the inorder traversal list 
-- of the tree, then pass that into the built in function elem
-- which takes a value and a list and determines if that
-- value is in the list
inBST :: Int -> Tree -> Bool
inBST x (Leaf i)     = checkEquals x i
inBST x (Node i l r) = elem x (inorder (Node i l r))
